//===- B3GenRegisterBankInfo.def -------------------------------*- C++ -*-==//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
/// \file
/// This file defines all the static objects used by B3RegisterBankInfo.
/// \todo This should be generated by TableGen, because the logic here can be
///  derived from register bank definition. Not yet implemented.
//===----------------------------------------------------------------------===//

namespace llvm {
const RegisterBankInfo::PartialMapping B3GenRegisterBankInfo::PartMappings[]{
    /* StartIdx, Length, RegBank */
    // 0: Int 32-bit value.
    {0, 32, B3::I32RegBank},
    // 1: Int 64-bit value.
    {0, 64, B3::I64RegBank},
    // 2: Float 32-bit value
    {0, 32, B3::F32RegBank},
    // 3: Float 64-bit value
    {0, 64, B3::F64RegBank},
    // 4: Int pointer
    {0, 64, B3::PTRRegBank},
};

// ValueMappings.
// Pointers to the entries in this array are returned by getValueMapping() and
// getCopyMapping().
//
// The array has the following structure:
// - At index 0 is the invalid entry.
// - After that, the mappings for the register types from PartialMappingIdx
//   follow. Each mapping consists of 3 entries, which is needed to cover
//   3-operands instructions.
// - Last, mappings for cross-register bank moves follow. Since COPY has only
//   2 operands, a mapping consists of 2 entries.
const RegisterBankInfo::ValueMapping B3GenRegisterBankInfo::ValMappings[]{
    /* BreakDown, NumBreakDowns */
    // 0: invalid
    {nullptr, 0},
    // 1: GPR 32-bit value.
    {&B3GenRegisterBankInfo::PartMappings[PMI_I32 - PMI_Min], 1},
    {&B3GenRegisterBankInfo::PartMappings[PMI_I32 - PMI_Min], 1},
    {&B3GenRegisterBankInfo::PartMappings[PMI_I32 - PMI_Min], 1},
    // 4: GPR 64-bit value.
    {&B3GenRegisterBankInfo::PartMappings[PMI_I64 - PMI_Min], 1},
    {&B3GenRegisterBankInfo::PartMappings[PMI_I64 - PMI_Min], 1},
    {&B3GenRegisterBankInfo::PartMappings[PMI_I64 - PMI_Min], 1},
    // 7: FPR 32-bit value.
    {&B3GenRegisterBankInfo::PartMappings[PMI_F32 - PMI_Min], 1},
    {&B3GenRegisterBankInfo::PartMappings[PMI_F32 - PMI_Min], 1},
    {&B3GenRegisterBankInfo::PartMappings[PMI_F32 - PMI_Min], 1},
    // 10: FPR 64-bit value.
    {&B3GenRegisterBankInfo::PartMappings[PMI_F64 - PMI_Min], 1},
    {&B3GenRegisterBankInfo::PartMappings[PMI_F64 - PMI_Min], 1},
    {&B3GenRegisterBankInfo::PartMappings[PMI_F64 - PMI_Min], 1},
    // 13: Pointer value.
    {&B3GenRegisterBankInfo::PartMappings[PMI_PTR - PMI_Min], 1},
    {&B3GenRegisterBankInfo::PartMappings[PMI_PTR - PMI_Min], 1},
    {&B3GenRegisterBankInfo::PartMappings[PMI_PTR - PMI_Min], 1},
};

// TODO Too simple!
const RegisterBankInfo::ValueMapping *
B3GenRegisterBankInfo::getValueMapping(PartialMappingIdx RBIdx) {
  assert(RBIdx != PartialMappingIdx::PMI_None && "No mapping needed for that");

  unsigned ValMappingIdx = RBIdx - PMI_Min;

  return &ValMappings[1 + 3 * ValMappingIdx];
}

const B3GenRegisterBankInfo::PartialMappingIdx
  B3GenRegisterBankInfo::BankIDToCopyMapIdx[]{
    PMI_None,
    PMI_F64,  // FPR
    PMI_I64,  // GPR
    PMI_PTR, // VEC
};

// TODO Too simple!
const RegisterBankInfo::ValueMapping *
B3GenRegisterBankInfo::getCopyMapping(unsigned DstBankID, unsigned SrcBankID,
                                       unsigned Size) {
  assert(DstBankID < B3::NumRegisterBanks && "Invalid bank ID");
  assert(SrcBankID < B3::NumRegisterBanks && "Invalid bank ID");
  PartialMappingIdx DstRBIdx = BankIDToCopyMapIdx[DstBankID];
  PartialMappingIdx SrcRBIdx = BankIDToCopyMapIdx[SrcBankID];
  assert(DstRBIdx != PMI_None && "No such mapping");
  assert(SrcRBIdx != PMI_None && "No such mapping");

  if (DstRBIdx == SrcRBIdx)
    return getValueMapping(DstRBIdx);

  assert(Size <= 128 && "Can currently handle types up to 128 bits (vectors)!");
  // TODO: This function needs to be updated to handle all cases for
  //       GPRs, FPRs and vectors. It currently only handles bitcasting to
  //       the same type and has only mainly been tested for bitcasting
  //       between different vector types.
  unsigned ValMappingIdx = DstRBIdx - PMI_Min;

  return &ValMappings[1 + 3 * ValMappingIdx];
}

} // namespace llvm
