//===- B3InstructionSelector.cpp ------------------------------*- C++ -*-==//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This file implements the targeting of the InstructionSelector class for
// B3.
// TODO: This should be generated by TableGen.
//
//===----------------------------------------------------------------------===//

#include "B3.h"
#include "B3InstrInfo.h"
#include "B3RegisterBankInfo.h"
#include "B3RegisterInfo.h"
#include "B3TargetMachine.h"
#include "B3Utils.h"
#include "MCTargetDesc/B3MCTargetDesc.h"
#include "llvm/ADT/APFloat.h"
#include "llvm/CodeGen/GlobalISel/GIMatchTableExecutorImpl.h"
#include "llvm/CodeGen/GlobalISel/GenericMachineInstrs.h"
#include "llvm/CodeGen/GlobalISel/InstructionSelector.h"
#include "llvm/CodeGen/MachineInstrBuilder.h"
#include "llvm/CodeGen/MachineRegisterInfo.h"
#include "llvm/Support/Debug.h"
#include "llvm/Transforms/Utils/PredicateInfo.h"

#define DEBUG_TYPE "b3-isel"

using namespace llvm;

namespace {

#define GET_GLOBALISEL_PREDICATE_BITSET
#include "B3GenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATE_BITSET

class B3InstructionSelector : public InstructionSelector {
  const B3Subtarget &STI;
  const B3InstrInfo &TII;
  const B3RegisterInfo &TRI;
  const RegisterBankInfo &RBI;
  MachineRegisterInfo *MRI;

  bool selectICmp(MachineInstr &I);
  bool selectFCmp(MachineInstr &I);
  bool selectLoad(MachineInstr &I);
  bool selectStore(MachineInstr &I);
public:
  B3InstructionSelector(const B3TargetMachine &TM,
                           const B3Subtarget &ST,
                           const RegisterBankInfo &RBI);
  void setupMF(MachineFunction &MF, GISelKnownBits *KB,
               CodeGenCoverage *CoverageInfo, ProfileSummaryInfo *PSI,
               BlockFrequencyInfo *BFI) override;
  // Common selection code. Instruction-specific selection occurs in spvSelect.
  bool select(MachineInstr &MI) override;
  static const char *getName() { return DEBUG_TYPE; }

  bool selectImpl(MachineInstr &I, CodeGenCoverage &CoverageInfo) const;
#define GET_GLOBALISEL_PREDICATES_DECL
#include "B3GenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATES_DECL

#define GET_GLOBALISEL_TEMPORARIES_DECL
#include "B3GenGlobalISel.inc"
#undef GET_GLOBALISEL_TEMPORARIES_DECL
};

} // end anonymous namespace

#define GET_GLOBALISEL_IMPL
#include "B3GenGlobalISel.inc"
#undef GET_GLOBALISEL_IMPL

B3InstructionSelector::B3InstructionSelector(const B3TargetMachine &TM,
                                                   const B3Subtarget &ST,
                                                   const RegisterBankInfo &RBI)
    : InstructionSelector(), STI(ST), TII(*ST.getInstrInfo()),
      TRI(*ST.getRegisterInfo()), RBI(RBI),
#define GET_GLOBALISEL_PREDICATES_INIT
#include "B3GenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATES_INIT
#define GET_GLOBALISEL_TEMPORARIES_INIT
#include "B3GenGlobalISel.inc"
#undef GET_GLOBALISEL_TEMPORARIES_INIT
{
}


bool B3InstructionSelector::select(MachineInstr &MI) {
  for (unsigned i = 0; i < MI.getNumOperands(); i++) {
    if (MI.getOperand(i).isReg()) {
      const TargetRegisterClass *TRC;
      Register VReg = MI.getOperand(i).getReg();
      const RegisterBank *RB = MRI->getRegBankOrNull(VReg);

      // ignore all operands with set regclass
      if (MRI->getRegClassOrNull(VReg))
        continue;
      switch (RB->getID()) {
      case B3::I32RegBankID:
        TRC = &B3::I32RegClass;
        break;
      case B3::I64RegBankID:
        TRC = &B3::I64RegClass;
        break;
      case B3::F32RegBankID:
        TRC = &B3::F32RegClass;
        break;
      case B3::F64RegBankID:
        TRC = &B3::F64RegClass;
        break;
      case B3::PTRRegBankID:
        TRC = &B3::PTRRegClass;
        break;
      }
      MRI->setRegClass(VReg, TRC);
    }
  }

  const auto Opcode = MI.getOpcode();
  if (Opcode == TargetOpcode::COPY) {
    Register InReg = MI.getOperand(1).getReg();
    Register OutReg = MI.getOperand(0).getReg();
    unsigned InRegID = MRI->getRegClass(InReg)->getID();
    unsigned OutRegID = MRI->getRegClass(OutReg)->getID();
    if (InRegID == B3::I64RegClassID && OutRegID == B3::F64RegClassID) {
      BuildMI(*MI.getParent(), MI, MI.getDebugLoc(), TII.get(B3::Cast64)).addDef(OutReg).addUse(InReg);
    }
    if (InRegID == B3::I64RegClassID && OutRegID == B3::PTRRegClassID) {
      BuildMI(*MI.getParent(), MI, MI.getDebugLoc(), TII.get(B3::PtrI64)).addDef(OutReg).addUse(InReg);
    }
    // TODO: DONT DO THIS JUST CHECK IF THIS COERCES A LOAD FROM INT TO FLOAT
    MI.eraseFromParent();
    return true;
  }
  if (!isPreISelGenericOpcode(Opcode))
    return true;
  if (Opcode == TargetOpcode::G_CONSTANT || Opcode == TargetOpcode::G_FCONSTANT) {
    unsigned Op;
    int64_t Imm;
    switch (MRI->getType(MI.getOperand(0).getReg()).getSizeInBits()) {
    case 32: {
      const TargetRegisterClass *TRC;
      switch (Opcode) {
      case TargetOpcode::G_CONSTANT:
        Op = B3::ConstI32;
        Imm = MI.getOperand(1).getCImm()->getZExtValue();
        TRC = &B3::I32RegClass;
        break;
      case TargetOpcode::G_FCONSTANT:
        Op = B3::ConstF32;
        Imm = MI.getOperand(1).getFPImm()->getValue().bitcastToAPInt().getZExtValue();
        TRC = &B3::F32RegClass;
        break;
      }
      MRI->setRegClass(MI.getOperand(0).getReg(), TRC);
    } break;
    case 64: {
      switch (Opcode) {
      case TargetOpcode::G_CONSTANT:
        Op = B3::ConstI64;
        Imm = MI.getOperand(1).getCImm()->getZExtValue();
        break;
      case TargetOpcode::G_FCONSTANT:
        Op = B3::ConstF64;
        Imm = MI.getOperand(1).getFPImm()->getValue().bitcastToAPInt().getZExtValue();
      }
      break;
    }
    default:
      report_fatal_error("unsupported integer immediate width!");
    }
    bool r = BuildMI(*MI.getParent(), MI, MI.getDebugLoc(), TII.get(Op))
      .addDef(MI.getOperand(0).getReg())
      .addImm(Imm)
      .constrainAllUses(TII, TRI, RBI);
    MI.eraseFromParent();
    return r;
  }
  if (Opcode == TargetOpcode::G_PTRTOINT) {
    BuildMI(*MI.getParent(), MI, MI.getDebugLoc(), TII.get(B3::CastPTR))
        .add(MI.getOperand(0))
        .add(MI.getOperand(1));
    MI.eraseFromParent();
    return true;
  }
  if (Opcode == TargetOpcode::G_ICMP)
    return selectICmp(MI);
  if (Opcode == TargetOpcode::G_FCMP)
    return selectFCmp(MI);
  if (Opcode == TargetOpcode::G_IMPLICIT_DEF) {
    unsigned Op = B3_TYPE_ADJUST(MRI->getRegClass(MI.getOperand(0).getReg()), B3::Undef);
    BuildMI(*MI.getParent(), MI, MI.getDebugLoc(), TII.get(Op)).add(MI.getOperand(0));
    MI.eraseFromParent();
    return true;
  }

  return selectImpl(MI, *CoverageInfo);
}

bool B3InstructionSelector::selectICmp(MachineInstr &I) {
  assert(I.getOpcode() == TargetOpcode::G_ICMP && "selectICmp expects the MI to be G_ICMP");
  unsigned Opc = 0;
  switch (I.getOperand(1).getPredicate()) {
  case CmpInst::ICMP_EQ:
    Opc = B3::EqI32;
  }
  I.getParent()->getParent()->getRegInfo().setRegClass(I.getOperand(0).getReg(), &B3::I32RegClass);
  BuildMI(*I.getParent(), I, I.getDebugLoc(), TII.get(Opc), I.getOperand(0).getReg()).add(I.getOperand(2)).add(I.getOperand(3));
  I.eraseFromParent();
  return true;
}
bool B3InstructionSelector::selectFCmp(MachineInstr &I) {
  assert(I.getOpcode() == TargetOpcode::G_FCMP && "selectFCmp expects the MI to be G_FCMP");
  unsigned Opc = 0;
  Register Lhs = I.getOperand(2).getReg();
  Register Rhs = I.getOperand(3).getReg();
  unsigned Size = MRI->getType(Lhs).getSizeInBits();
  switch (I.getOperand(1).getPredicate()) {
  // this is a gigantic ugly hack TODO: implement Ordered in B3
  case CmpInst::FCMP_ORD: {
    Register NewLhs = MRI->createVirtualRegister(&B3::I32RegClass);
    BuildMI(*I.getParent(), I, I.getDebugLoc(), TII.get(Size == 64 ? B3::EqF64 : B3::EqF32))
        .addDef(NewLhs)
        .addUse(Lhs)
        .addUse(Lhs);
    Lhs = NewLhs;
    Register NewRhs = MRI->createVirtualRegister(&B3::I32RegClass);
    BuildMI(*I.getParent(), I, I.getDebugLoc(), TII.get(Size == 64 ? B3::EqF64 : B3::EqF32))
        .addDef(NewRhs)
        .addUse(Rhs)
        .addUse(Rhs);
    Rhs = NewLhs;
    Opc = B3::AndI32;
    break;
  }
  case CmpInst::FCMP_OEQ:
    Opc = Size == 64 ? B3::EqF64 : B3::EqF32;
    break;
  }
  BuildMI(*I.getParent(), I, I.getDebugLoc(), TII.get(Opc), I.getOperand(0).getReg()).addUse(Lhs).addUse(Rhs);
  I.eraseFromParent();
  return true;
}

void B3InstructionSelector::setupMF(MachineFunction &MF, GISelKnownBits *KB,
                                       CodeGenCoverage *CoverageInfo,
                                       ProfileSummaryInfo *PSI,
                                       BlockFrequencyInfo *BFI) {
  MRI = &MF.getRegInfo();
  InstructionSelector::setupMF(MF, KB, CoverageInfo, PSI, BFI);
}

namespace llvm {
InstructionSelector *
createB3InstructionSelector(const B3TargetMachine &TM,
                               const B3Subtarget &Subtarget,
                               const RegisterBankInfo &RBI) {
  return new B3InstructionSelector(TM, Subtarget, RBI);
}
} // namespace llvm
